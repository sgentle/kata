// Generated by CoffeeScript 1.10.0
(function() {
  var add, addPath, andify, basicNums, binaryOp, blockWrap, camelise, checkConstraints, constraint, defaultopts, diff, divide, escodegen, esprima, even, ex, freeVar, fun, gen, generate, guardConstraints, hBinaryOp, hadd, hdivide, hetRand, hmultiply, homRand, hsubtract, i, j, len, letterMap, listify, maybeGenerate, multiply, negate, negative, nextFree, normalise, num, numToLetters, nums, odd, opposites, opreducer, ops, parse, positive, randBody, randOf, subtract, thrower, x,
    slice = [].slice;

  escodegen = typeof window === 'undefined' ? require('escodegen') : window.escodegen;

  esprima = typeof window === 'undefined' ? require('esprima') : window.esprima;

  parse = function(str) {
    return esprima.parse("(" + str + ")").body[0].expression;
  };

  generate = escodegen.generate;

  nextFree = 1;

  letterMap = 'abcdefghijklmnopqrstuvwxyz';

  numToLetters = function(num) {
    var letters;
    letters = '';
    while (num > 0) {
      letters = letterMap[(num - 1) % 26] + letters;
      num = Math.floor((num - 1) / 26);
    }
    return letters;
  };

  freeVar = function() {
    return numToLetters(nextFree++);
  };

  freeVar.reset = function() {
    return nextFree = 1;
  };

  num = function() {
    var variable;
    variable = freeVar();
    return {
      description: ["number"],
      code: {
        type: 'Identifier',
        name: variable
      },
      variables: [variable]
    };
  };

  nums = function(n) {
    var elem, elems;
    if (n == null) {
      n = 2;
    }
    elems = (function() {
      var j, ref, results;
      results = [];
      for (j = 1, ref = n; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--) {
        results.push({
          type: 'Identifier',
          name: freeVar()
        });
      }
      return results;
    })();
    return {
      description: ["numbers"],
      code: {
        type: 'ArrayExpression',
        elements: elems
      },
      variables: (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = elems.length; j < len; j++) {
          elem = elems[j];
          results.push(elem.name);
        }
        return results;
      })()
    };
  };

  listify = function(names) {
    if (names.length === 1) {
      return names[0];
    }
    return names.slice(0, -1).join(', ') + ' and ' + names[names.length - 1];
  };

  andify = function(expr, newexpr) {
    return {
      type: 'LogicalExpression',
      operator: '&&',
      left: expr,
      right: newexpr
    };
  };

  constraint = function(name, constrainer) {
    return function(expr) {
      var v;
      return {
        description: [name].concat(expr.description || []),
        code: expr.code,
        constraints: [
          {
            description: (listify(expr.variables)) + " must be " + name,
            code: ((function() {
              var j, len, ref, results;
              ref = expr.variables;
              results = [];
              for (j = 0, len = ref.length; j < len; j++) {
                v = ref[j];
                results.push(constrainer({
                  type: 'Identifier',
                  name: v
                }));
              }
              return results;
            })()).reduce(andify)
          }
        ].concat(expr.constraints || []),
        variables: expr.variables
      };
    };
  };

  even = constraint('even', function(expr) {
    return {
      type: 'BinaryExpression',
      operator: '==',
      left: {
        type: 'BinaryExpression',
        operator: '%',
        left: expr,
        right: {
          type: 'Literal',
          value: 2
        }
      },
      right: {
        type: 'Literal',
        value: 0
      }
    };
  });

  odd = constraint('odd', function(expr) {
    return {
      type: 'BinaryExpression',
      operator: '!=',
      left: {
        type: 'BinaryExpression',
        operator: '%',
        left: expr,
        right: {
          type: 'Literal',
          value: 2
        }
      },
      right: {
        type: 'Literal',
        value: 0
      }
    };
  });

  positive = constraint('positive', function(expr) {
    return {
      type: 'BinaryExpression',
      operator: '>=',
      left: expr,
      right: {
        type: 'Literal',
        value: 0
      }
    };
  });

  negative = constraint('negative', function(expr) {
    return {
      type: 'BinaryExpression',
      operator: '<',
      left: expr,
      right: {
        type: 'Literal',
        value: 0
      }
    };
  });

  binaryOp = function(name, preposition, operator) {
    return function(num1, num2) {
      return {
        description: [name].concat(num1.description || [], preposition, num2.description || []),
        code: {
          type: 'BinaryExpression',
          operator: operator,
          left: num1.code,
          right: num2.code
        },
        constraints: (num1.constraints || []).concat(num2.constraints || []),
        variables: (num1.variables || []).concat(num2.variables || [])
      };
    };
  };

  add = binaryOp('add', 'to', '+');

  subtract = binaryOp('subtract', 'from', '-');

  multiply = binaryOp('multiply', 'by', '*');

  divide = binaryOp('divide', 'by', '/');

  opreducer = function(op) {
    return function(vals, val) {
      return {
        type: 'BinaryExpression',
        operator: op,
        left: vals,
        right: val
      };
    };
  };

  basicNums = 'zero one two three four five six seven eight nine ten'.split(' ');

  hBinaryOp = function(name, operator) {
    return function(expr) {
      var count, elems;
      elems = expr.code.elements;
      if (!elems || elems.length < 2) {
        throw new Error("Need at least 2 elements to " + name);
      }
      count = basicNums[elems.length] || elems.length;
      return {
        description: [name, count].concat(expr.description),
        code: elems.reduce(opreducer(operator)),
        constraints: expr.constraints,
        variables: expr.variables
      };
    };
  };

  hadd = hBinaryOp('add', '+');

  hsubtract = hBinaryOp('subtract', '-');

  hmultiply = hBinaryOp('multiply', '*');

  hdivide = hBinaryOp('divide', '/');

  blockWrap = function(code) {
    return {
      type: 'BlockStatement',
      body: [code]
    };
  };

  thrower = function(constraint) {
    return {
      type: 'ThrowStatement',
      argument: {
        type: 'NewExpression',
        callee: {
          type: 'Identifier',
          name: 'Error'
        },
        "arguments": [
          {
            type: 'Literal',
            value: constraint.description
          }
        ]
      }
    };
  };

  checkConstraints = function(expr) {
    var code, constraints, j;
    code = {
      type: "ReturnStatement",
      argument: expr.code
    };
    constraints = expr.constraints || [];
    for (j = constraints.length - 1; j >= 0; j += -1) {
      constraint = constraints[j];
      code = {
        type: "IfStatement",
        test: constraint.code,
        consequent: blockWrap(code),
        alternate: blockWrap(thrower(constraint))
      };
    }
    return {
      description: expr.description,
      code: blockWrap(code),
      constraints: expr.constraints,
      variables: expr.variables
    };
  };

  guardConstraints = function(expr) {
    var j, len, ref, statements;
    statements = [];
    ref = expr.constraints || [];
    for (j = 0, len = ref.length; j < len; j++) {
      constraint = ref[j];
      statements.push({
        type: 'IfStatement',
        test: negate(constraint.code),
        consequent: thrower(constraint)
      });
    }
    statements.push({
      type: 'ReturnStatement',
      argument: expr.code
    });
    return {
      description: expr.description,
      code: {
        type: 'BlockStatement',
        body: statements
      },
      constraints: expr.constraints,
      variables: expr.variables
    };
  };

  camelise = function(description) {
    var i, j, len, results, word;
    results = [];
    for (i = j = 0, len = description.length; j < len; i = ++j) {
      word = description[i];
      if (i === 0) {
        results.push(word);
      } else {
        results.push(word[0].toUpperCase() + word.slice(1));
      }
    }
    return results;
  };

  fun = function(expr) {
    var x;
    return {
      type: 'FunctionExpression',
      id: {
        type: "Identifier",
        name: camelise(expr.description).join('')
      },
      params: (function() {
        var j, len, ref, results;
        ref = expr.variables;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          x = ref[j];
          results.push({
            type: "Identifier",
            name: x
          });
        }
        return results;
      })(),
      body: expr.code.type === 'BlockStatement' ? expr.code : blockWrap(expr.code)
    };
  };

  opposites = {};

  ops = '== === < > && || <= >= !== !='.split(' ');

  for (i = j = 0, len = ops.length; j < len; i = ++j) {
    x = ops[i];
    opposites[x] = ops[ops.length - 1 - i];
  }

  negate = function(expr) {
    var op, type;
    type = expr.type;
    op = expr.operator;
    if (type === 'BinaryExpression' && (opposites[op] != null)) {
      expr.operator = opposites[op];
      return expr;
    } else if (type === 'LogicalExpression') {
      expr.operator = opposites[op];
      expr.left = negate(expr.left);
      expr.right = negate(expr.right);
      return expr;
    } else if (type === 'UnaryExpression' && op === '!') {
      return expr.argument;
    } else {
      return {
        type: 'UnaryExpression',
        operator: '!',
        prefix: true,
        argument: expr
      };
    }
  };

  defaultopts = {
    blocks: true,
    negation: false
  };

  normalise = function(expr, opts) {
    var k, v;
    if (opts == null) {
      opts = defaultopts;
    }
    switch (expr != null ? expr.type : void 0) {
      case 'UnaryExpression':
        if (!opts.negation) {
          break;
        }
        if (expr.operator === '!') {
          expr = negate(expr.argument);
        }
        break;
      case 'IfStatement':
        if (!opts.blocks) {
          break;
        }
        if (expr.consequent.type !== 'BlockStatement') {
          expr.consequent = blockWrap(expr.consequent);
        }
        if (expr.alternate && expr.alternate.type !== 'BlockStatement') {
          expr.alternate = blockWrap(expr.alternate);
        }
    }
    if ((expr != null ? expr.type : void 0) || Array.isArray(expr)) {
      for (k in expr) {
        v = expr[k];
        if ((v != null) && typeof v === 'object') {
          expr[k] = normalise(v, opts);
        }
      }
    }
    return expr;
  };

  randOf = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return args[Math.floor(Math.random() * args.length)];
  };

  hetRand = function() {
    var first, second;
    first = randOf(even, odd, positive, negative);
    second = first;
    while (second === first) {
      second = randOf(even, odd, positive, negative);
    }
    return randOf(add, subtract, multiply, divide)(first(num()), second(num()));
  };

  homRand = function() {
    return randOf(hadd, hsubtract, hmultiply, hdivide)(randOf(even, odd, positive, negative)(nums(randOf(2, 3))));
  };

  randBody = function() {
    return randOf(hetRand, homRand)();
  };

  gen = function() {
    var body;
    freeVar.reset();
    body = randBody();
    return {
      question: fun(checkConstraints(body)),
      answer: normalise(fun(guardConstraints(JSON.parse(JSON.stringify(body))))),
      testMe: function() {
        console.log("Convert this to early-exit form:");
        return console.log(generate(this.question, {
          format: {
            indent: {
              style: '  '
            }
          }
        }));
      },
      checkMe: function(answer) {
        var d;
        answer = normalise(parse(answer));
        d = diff(this.answer, answer);
        if (d) {
          console.log("In", d[2].join('\n  > '));
          console.log("Expected", d[0].type && maybeGenerate(d[0]) || d[0]);
          return console.log("Got", d[1].type && maybeGenerate(d[1]) || d[1]);
        } else {
          return console.log("Right!");
        }
      }
    };
  };

  maybeGenerate = function(x) {
    var error;
    try {
      return generate(x);
    } catch (error) {
      return null;
    }
  };

  addPath = function(path, tree, k) {
    var sub;
    path = path.slice();
    path[path.length - 1] += isNaN(k) ? "." + k : "[" + k + "]";
    sub = tree != null ? tree.type : void 0;
    if (sub) {
      path.push(sub);
    }
    return path;
  };

  diff = function(tree1, tree2, path) {
    var d, k;
    if (path == null) {
      path = [tree2.type];
    }
    if (tree1 === tree2) {
      return null;
    }
    if (typeof tree1 !== typeof tree2 || Array.isArray(tree1) !== Array.isArray(tree2)) {
      return [tree1, tree2, path];
    }
    if (typeof tree1 === 'object') {
      if (tree1.type !== tree2.type) {
        return [tree1, tree2, path];
      }
      for (k in tree1) {
        if (d = diff(tree1[k], tree2[k], addPath(path, tree2[k], k))) {
          return d;
        }
      }
      return null;
    }
    return [tree1, tree2, path];
  };

  ex = {
    normalise: normalise,
    diff: diff,
    gen: gen,
    generate: generate,
    parse: parse
  };

  if (typeof module === 'undefined' && typeof 'window' !== 'undefined') {
    window.kata = ex;
  } else {
    module.exports = ex;
  }

}).call(this);
